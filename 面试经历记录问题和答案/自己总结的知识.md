# java：

JDK和jre和JVM： 

java三大特性：封装，继承，多态

重载和重写：

抽象类和接口：为啥会使用抽象类？

## 集合：ArrayList  特别重要的**HashMap**：

Java集合中实际存放的只是对象的引用，每个集合元素都是一个引用变量，实际内容都放在堆内存或者方法区里面，但是基本数据类型是在栈内存上分配空间的，栈上的数据随时就会被收回的。

### list集合：有序，可重复，元素有下标

#### ArrayList:基于数组

**建议给一个初始化的值，减少扩容的次数**，如果new 时参数为空，先创建一个空的对象数组，第一次执行add()会变为默认容量10；

 扩容1.5倍(先检查数组长度为几，然后超过规定的长度，需要扩容，**扩容机制：**是你的初始化容量右移一位，相当于扩容原容量的1.5倍）

优点：查询效率高：ArrayLIst是连续存放元素的，找到第一个元素的首地址，再加上每个元素的占据的字节大小就能定位到对应的元素。

缺点：随机增删效率低，无法存储较大的数量（无法找到一个很大的连续存储空间）

#### vector：基于数组，线程安全

每个方法加了synchronize关键字

初始容量为10，扩容为2倍

#### Linklist：基于双向链表



:

### set集合：

hashset:

Treeset：

### Map集合：

### Hashmap：

1.7之前：数组+单链表

1.8 之后：数组+单链表+红黑树

TreeMap：底层是二叉树，默认是由小到大排序



## IO流：

## 多线程：

## JVM的考点:

HotSpot虚拟机：

![img](https://img2018.cnblogs.com/blog/774371/201906/774371-20190625165606099-684954765.jpg)

**①类加载检查：** 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

**②分配内存：** 在**类加载检查**通过后，接下来虚拟机将为新生对象**分配内存**。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。**分配方式**有 **“指针碰撞”** 和 **“空闲列表”** 两种，**选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定**。

**内存分配的两种方式：（补充内容，需要掌握）**

选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的

![img](https://img2018.cnblogs.com/blog/774371/201906/774371-20190625165620681-1534548019.jpg)

**内存分配并发问题（补充内容，需要掌握）**

在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：

•**CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**•**TLAB：** 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配

**③初始化零值：** 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

**④设置对象头：** 初始化零值完成之后，**虚拟机要对对象进行必要的设置**，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。** 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

**⑤执行 init 方法：** 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，`<init>` 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 `<init>` 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。



### 3.3 对象的访问定位

建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有**①使用句柄**和**②直接指针**两种：

•**句柄：** 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；

![img](https://img2018.cnblogs.com/blog/774371/201906/774371-20190625165639416-600429715.jpg)

- **直接指针****：** 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。

![img](https://img2018.cnblogs.com/blog/774371/201906/774371-20190625165652608-1144274613.jpg)

**这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。**

##  

本地方法栈：**拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

堆：Java 虚拟机所管理的内存中最大的一块，Java 堆是**所有线程共享的一块内存区域**，在虚拟机启动时创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。**

方法区：**方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来**

JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。



## 垃圾处理的算法：

## 反射：

## JDBC：

### 设计模式：

单例模式：

工厂模式：

代理模式：



# 数据库

## MySQL数据库

索引

四个操作，聚合函数

优化数据库：

## Redis数据库

五大基本数据类型：
命令

# Spring的知识

IOC：

AOP:

### 注解：autoweird



# springMVC：

过程： 

注解：requestMapping：

# springboot：

原理：

解释：

# Mybatis：

动态SQL

一二级缓存：

# SpringCLoud微服务的知识：

五大组件：

# 数据结构：

栈：

链：

哈希表：

排序：

二叉树：

## 算法：

# Linux：

# 前端知识：

js: